// backend/server.js
// Combined, deploy-ready server: auth, expenses, categories, salary/limit, profile,
// + frontend static routes for Vercel, + monthly auto-save check, + update endpoints.

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;
const __dirname = path.resolve();

app.use(express.json());
app.use(cors());

// ---------- Mongoose models (simple single-file models to keep everything in one file) ----------
const userSchema = new mongoose.Schema({
  username: String,
  email: { type: String, unique: true },
  password: String,
  salary: {
    amount: { type: Number, default: 0 },
    type: { type: String, default: 'monthly' }
  },
  limit: { type: Number, default: 0 },
  savedAmount: { type: Number, default: 0 },
  lastSavedMonth: { type: String, default: null }, // format: YYYY-MM
  categories: { type: [String], default: [] },
  expenses: [
    {
      category: String,
      amount: Number,
      type: { type: String, enum: ['expense','saving'], default: 'expense' },
      date: { type: Date, default: Date.now }
    }
  ]
}, { timestamps: true });

const User = mongoose.models.User || mongoose.model('User', userSchema);

// ---------- Connect to MongoDB ----------
mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(()=> console.log('✅ MongoDB connected'))
  .catch(err => console.error('❌ MongoDB connection error:', err.message));

// ---------- Helper functions ----------
function monthKeyFromDate(d = new Date()){
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; // "2025-09"
}

// When profile is fetched, check if a new month started. If yes, add remaining -> savedAmount and update lastSavedMonth.
async function applyMonthlyAutoSave(user){
  try{
    const salaryAmount = Number(user.salary?.amount || 0);
    if (!salaryAmount) {
      // nothing to do
      return user;
    }
    const nowKey = monthKeyFromDate(new Date());
    if (user.lastSavedMonth === nowKey) return user; // already applied this month

    // compute remaining = salary - sum(expenses of type 'expense') for the current stored expenses
    const totalExpenses = (user.expenses || []).reduce((s,e) => s + (e.type === 'expense' ? Number(e.amount || 0) : 0), 0);
    const remaining = Math.max(0, salaryAmount - totalExpenses);

    if (remaining > 0) {
      user.savedAmount = (Number(user.savedAmount || 0)) + remaining;
    }
    // set lastSavedMonth to now
    user.lastSavedMonth = nowKey;

    // Optionally: reset monthly-related items (you may decide to clear expenses each month; here we keep expenses for history)
    await user.save();
    return user;
  }catch(err){
    console.warn('applyMonthlyAutoSave error', err);
    return user;
  }
}

// ---------- API endpoints (preserve & extend previous behavior) ----------

// Signup
app.post('/signup', async (req, res) => {
  try{
    const { username, email, password } = req.body;
    if (!email || !password) return res.status(400).json({ message: 'Email & password required' });

    const exists = await User.findOne({ email });
    if (exists) return res.status(400).json({ message: 'User already exists' });

    const user = new User({
      username: username || email.split('@')[0],
      email,
      password, // NOTE: for production, hash passwords (bcrypt). kept plain for compatibility with your existing frontend
      categories: ['Trust','Rent','EMI & Loans','Medical Expenses','Vacation','Electricity Bills']
    });
    await user.save();
    return res.status(201).json({ message: 'Signup successful', user: { email: user.email, username: user.username } });
  }catch(err){
    console.error('signup error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Login
app.post('/login', async (req, res) => {
  try{
    const { email, password } = req.body;
    if (!email || !password) return res.status(400).json({ message: 'Email & password required' });

    const user = await User.findOne({ email, password });
    if (!user) return res.status(401).json({ message: 'Invalid credentials' });

    // You previously used tokens in frontend. For simplicity return a simple token-like value (in production use JWT).
    const fakeToken = Buffer.from(`${user._id}:${Date.now()}`).toString('base64');
    return res.json({ message: 'Login success', token: fakeToken, user: { email: user.email, username: user.username } });
  }catch(err){
    console.error('login error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Profile (fetch)
// If client sends ?email=... we use that, else try req.query or authorization flow (kept simple)
app.get('/profile', async (req, res) => {
  try{
    // prefer email query param (frontend used token before; but earlier client used /profile with token — keep both working)
    const email = req.query.email || (req.body && req.body.email) || null;
    let user;
    if (email) user = await User.findOne({ email });
    else {
      // if no email given, return a placeholder or error
      return res.status(400).json({ message: 'Email query required: /profile?email=you@domain.com' });
    }
    if (!user) return res.status(404).json({ message: 'User not found' });

    // apply monthly auto-save (adds remaining to savedAmount once per month)
    user = await applyMonthlyAutoSave(user);

    // compute totalExpenses, remaining
    const totalExpenses = (user.expenses || []).reduce((s,e) => s + (e.type === 'expense' ? Number(e.amount || 0):0), 0);
    const remaining = Math.max(0, Number(user.salary?.amount || 0) - totalExpenses);

    return res.json({
      email: user.email,
      username: user.username,
      salary: { amount: user.salary?.amount || 0, type: user.salary?.type || 'monthly' },
      limit: user.limit || 0,
      savedAmount: user.savedAmount || 0,
      lastSavedMonth: user.lastSavedMonth || null,
      expenses: user.expenses || [],
      totalExpenses,
      remaining
    });
  }catch(err){
    console.error('profile error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Categories (get)
app.get('/categories', async (req, res) => {
  try{
    // you can pass email to get user-specific categories; fallback to defaults
    const email = req.query.email || null;
    if (email) {
      const user = await User.findOne({ email });
      if (!user) return res.json([]); // empty
      return res.json((user.categories || []).map(name => ({ name })));
    }
    // generic defaults
    const defaults = ['Trust','Rent','EMI & Loans','Medical Expenses','Vacation','Electricity Bills'];
    return res.json(defaults.map(n => ({ name: n })));
  }catch(err){
    console.error('categories error', err);
    return res.status(500).json([]);
  }
});

// Add category
app.post('/category', async (req, res) => {
  try{
    const { email, name } = req.body;
    if (!email || !name) return res.status(400).json({ message: 'email & name required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });
    user.categories = user.categories || [];
    if (!user.categories.includes(name)) user.categories.push(name);
    await user.save();
    return res.json({ message: 'Category added', categories: user.categories });
  }catch(err){
    console.error('add category error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Expenses (list)
app.get('/expenses', async (req, res) => {
  try{
    const email = req.query.email;
    if (!email) return res.status(400).json({ message: 'email required' });
    const user = await User.findOne({ email });
    if (!user) return res.json({ expenses: [], totalExpenses: 0, remaining: user?.salary?.amount || 0 });
    const expenses = (user.expenses || []).map(e => ({ _id: e._id || null, category: e.category, amount: e.amount, type: e.type, date: e.date }));
    const totalExpenses = expenses.reduce((s,e) => s + (e.type === 'expense' ? Number(e.amount || 0):0), 0);
    const remaining = Math.max(0, Number(user.salary?.amount || 0) - totalExpenses);
    return res.json({ expenses, totalExpenses, remaining });
  }catch(err){
    console.error('get expenses error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Add expense
app.post('/expense', async (req, res) => {
  try{
    const { email, category, amount, type } = req.body;
    if (!email || !category || !amount) return res.status(400).json({ message: 'email, category, amount required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });

    const exp = { category, amount: Number(amount), type: type || 'expense', date: new Date() };
    user.expenses.push(exp);
    await user.save();

    // compute new totals for response
    const totalExpenses = (user.expenses || []).reduce((s,e) => s + (e.type === 'expense' ? Number(e.amount || 0):0), 0);
    const remaining = Math.max(0, Number(user.salary?.amount || 0) - totalExpenses);

    // If limit exceeded — we don't want server to alert UI but we can include a flag
    const limitExceeded = user.limit && (totalExpenses > Number(user.limit || 0));

    return res.json({ message: 'Expense added', expense: exp, totalExpenses, remaining, limitExceeded });
  }catch(err){
    console.error('add expense error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Update expense (PUT /expense/:id) - Mongoose subdocument id matching
app.put('/expense/:id', async (req, res) => {
  try{
    const id = req.params.id;
    const { email, category, amount, type } = req.body;
    if (!email) return res.status(400).json({ message: 'email required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });

    const idx = user.expenses.findIndex(e => String(e._id) === String(id) || (!e._id && false));
    if (idx === -1) return res.status(404).json({ message: 'Expense not found' });

    if (category) user.expenses[idx].category = category;
    if (amount) user.expenses[idx].amount = Number(amount);
    if (type) user.expenses[idx].type = type;
    user.expenses[idx].date = new Date();

    await user.save();
    return res.json({ message: 'Expense updated' });
  }catch(err){
    console.error('update expense error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Delete expense
app.delete('/expense/:id', async (req, res) => {
  try{
    const id = req.params.id;
    const email = req.query.email || req.body.email;
    if (!email) return res.status(400).json({ message: 'email required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });
    const beforeLen = user.expenses.length;
    user.expenses = user.expenses.filter(e => String(e._id) !== String(id));
    if (user.expenses.length === beforeLen) return res.status(404).json({ message: 'Expense not found' });
    await user.save();
    return res.json({ message: 'Deleted' });
  }catch(err){
    console.error('delete expense error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Salary set/update
app.post('/salary', async (req, res) => {
  try{
    const { email, amount, type } = req.body;
    if (!email || !amount) return res.status(400).json({ message: 'email & amount required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });
    user.salary = { amount: Number(amount), type: type || 'monthly' };
    await user.save();
    return res.json({ message: 'Salary saved' });
  }catch(err){
    console.error('salary error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Limit
app.post('/limit', async (req, res) => {
  try{
    const { email, limit } = req.body;
    if (!email) return res.status(400).json({ message: 'email required' });
    const user = await User.findOneAndUpdate({ email }, { $set: { limit: Number(limit || 0) } }, { new: true });
    if (!user) return res.status(404).json({ message: 'User not found' });
    return res.json({ message: 'Limit saved', limit: user.limit });
  }catch(err){
    console.error('limit error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Update Remaining (used when front-end deducts and wants to persist)
app.post('/updateRemaining', async (req, res) => {
  try{
    const { email, remaining } = req.body;
    if (!email) return res.status(400).json({ message: 'email required' });
    // we treat remaining as derived: we do not store remaining separately; but store it as savedAmount or keep for compatibility
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });
    // Optionally store a derived field 'lastRemaining' for debugging
    user._lastRemaining = Number(remaining || 0);
    await user.save();
    return res.json({ message: 'Remaining updated' });
  }catch(err){
    console.error('updateRemaining error', err);
    return res.status(500).json({ message: 'Server error' });
  }
});

// Update Savings (used by monthly auto-save endpoint if frontend wants to push)
app.post('/updateSavings', async (req, res) => {
  try{
    const { email, totalSaved, lastSavedMonth, remainingAfterReset } = req.body;
    if (!email) return res.status(400).json({ message: 'email required' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'User not found' });
    if (typeof totalSaved !== 'undefined') user.savedAmount = Number(totalSaved || 0);
    if (lastSavedMonth) user.lastSavedMonth = lastSavedMonth;
    if (typeof remainingAfterReset !== 'undefined') user._lastRemaining = Number(remainingAfterReset);
    await user.save();
    return res.json({ message: 'Savings updated' });
  }catch(err){
    console.error('updateSavings error', err);
    return res.status(500).json({ message: 'Server error' });
  }
}

// ---------- STATIC FRONTEND ROUTES for VERCEL deployment ----------
app.use(express.static(__dirname)); // serve files from backend folder (where your HTML/CSS/JS are)

app.get('/', (req,res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});
app.get('/login', (req,res) => {
  res.sendFile(path.join(__dirname, 'login.html'));
});
app.get('/signup', (req,res) => {
  res.sendFile(path.join(__dirname, 'signup.html'));
});
app.get('/dashboard', (req,res) => {
  res.sendFile(path.join(__dirname, 'dashboard.html'));
});
app.get('/about', (req,res) => {
  const f = path.join(__dirname, 'about.html');
  if (require('fs').existsSync(f)) return res.sendFile(f);
  // fallback to index if no about file
  return res.sendFile(path.join(__dirname, 'index.html'));
});
app.get('/profile', (req,res) => {
  // if frontend profile page exists, serve; otherwise index
  const f = path.join(__dirname, 'profile.html');
  if (require('fs').existsSync(f)) return res.sendFile(f);
  return res.sendFile(path.join(__dirname, 'index.html'));
});
app.get('/savings', (req,res) => {
  const f = path.join(__dirname, 'savings.html');
  if (require('fs').existsSync(f)) return res.sendFile(f);
  return res.sendFile(path.join(__dirname, 'index.html'));
});

// fallback for everything else (so deep links work)
app.get('*', (req,res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// ---------- Start ----------
app.listen(PORT, ()=> {
  console.log(`🚀 Server listening on port ${PORT}`);
});

